# 다양한 의존관계 주입 방법
Spring에서 지원하는 의존관계는 크게 4가지가 있다.  
   
* **생성자 주입**     
* Setter 주입     
* 필드 주입      
* 일반 메서드 주입     

## 생성자 주입  
우선, 지금 현재 가장 추천하는 방법으로   
이름 그대로 `생성자`를 통해서 의존 관계를 주입 받는 방법이다.   
     
**특징**    
* 생성자 호출시점에 딱 1번 호출되는 것이 보장된다.     
* 생성자 호출시점이기에 빈이 등록 되는 과정에서 연관된 의존 관계까지 묶어서 등록된다.     
* **불변**, **필수** 의존관계에 사용된다.    
  
```java
import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
    // ...생략
}
```
그리고 **생성자 주입이 가진 가장 큰 장점이 하나있다.**        
바로, **생성자가 단 한 개뿐일 때 `@Autowired`를 자동으로 주입해준다.**     
   
즉, 위와 같은 코드는 아래와 같이 표현을 할 수 있다.  
    
**@Autowired 생략 형태**
```java
import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
   
    // 여기가 생략되었다.   
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
    // ...생략
}
```
**그렇다면 생성자가 2개 이상이라면 전부 `@Autowired`를 해줘야하나?🤔**     
`@Autowired`를 하는 이유는 여러 생성자중 의존 관계를 주입시킬 단 하나의 생성자를 찾기 위함이다.   
그러니 **의존 관계를 주입받는 생성자에게만 `@Autowired`를 해주자**       
      
생성자 주입은 **불변 상태**를 만들 수 있다는 큰 장점을 가지고 있다.    
하지만 꼭 불변으로만 만들어아 되는 것은 아니기에 `final` 키워드를 사용하지 않아도 된다.   
하지만, 이전에도 언급했듯 **불변으로 만드는 것을 최대한 지향하기에**   
유일하게 불변으로 의존 관계를 주입해주는 `생성자 주입`을 강력하게 추천한다.     
       
## Setter 주입 
Setter 메서드를 통해, 이와 연관된 필드의 값을 변경하는 의존 관계 주입 방법이다.     
  
**특징**      
* **선택**,**변경** 가능성이 있는 의존 관계에서 사용된다.    
* 자바빈 프로퍼티 규약의 Setter 메서드 방식을 사용하는 방법이다.     
  * 스프링에서는 `자바빈 프로퍼티 규약`을 이용한 자동화 기능이 많다.  
  * Setter 주입도 이러한 자동화 중 하나이니 `자바빈 프로퍼티 규약`에 대해서 알아보는 것을 추천한다.   

```java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
     
    // ...생략  
}
```

스프링 컨테이너는 2가지 라이프 사이클을 가지고 있다.   
  
1. 스프링 빈을 등록  
2. 연관 관계를 자동으로 주입한다.  
  
Setter 메서드 또한, `@Autowired`를 통해, 연관 관계 자동 주입을 받는다.    
생성자와 달리, 빈이 등록된 후에 의존 관계를 주입하는 방식이다.      
그리고 어떤 Setter 주입이 먼저 실행될지 순서는 보장되지 않는다.      

참고로, 선택적으로 의존 관계를 주입 받을 수 있다는 말은 아래와 같다.     
```java
    @Autowired(required = false)
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }
```
`@Autowired`의 `required` 속성을 이용해서 필수로 의존받아야 하는지 여부를 지정해줄 수 있다.   
사실, `@Autowired` 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다.    
그렇기에 주입할 대상이 없어도 동작하게 하려면 `@Autowired(required = false)` 로 지정하면 된다.
    
**만약, 생성자 주입이랑 Setter가 동시에 존재한다면? 🤔**        
  
```java
import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        System.out.println("memberRepository = " + memberRepository);
        System.out.println("discountPolicy = " + discountPolicy);
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    @Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        System.out.println("memberRepository = " + memberRepository);
        this.memberRepository = memberRepository;
    }

    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        System.out.println("discountPolicy = " + discountPolicy);
        this.discountPolicy = discountPolicy;
    }

}

```
**결과**
```java
memberRepository = hello.core.member.MemoryMemberRepository@78dd667e
discountPolicy = hello.core.discount.RateDiscountPolicy@10db82ae
memberRepository = hello.core.member.MemoryMemberRepository@78dd667e
discountPolicy = hello.core.discount.RateDiscountPolicy@10db82ae
```
실제로 돌려보면, 두 의존 관계 주입 방법 모두 실행되는 것을 알 수 있다.     
사실, 앞서 말했듯이 두 의존 관계 주입 방법의 시점이 달라서 가능했던 것이다.   
        
**개인적인 궁금증 순서는 어떻게 될까? 🤔**        
        
        
## 필드 주입      
이름 그대로 필드에 바로 주입하는 방법이다.    
한 가지 특이점이 있는데, 접근 지정자가 `private`여도 의존 관계를 주입할 수 있다.     
이는 자바의 `Reflection`이라는 기능을 이용해서 빈을 주입하기 때문이다.    
  
**특징**
* 코드가 간결하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.
* DI 프레임워크가 없으면 아무것도 할 수 없다.

```java
@Component
public class OrderServiceImpl implements OrderService {

    @Autowired  private MemberRepository memberRepository;
    @Autowired  private DiscountPolicy discountPolicy;

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
    
    // 테스트 용도
    public MemberRepository getMemberRepository() {
        return memberRepository;
    }

}
```
하지만, 이와 같이 코드를 작성하면 테스트를 하기 힘들다는 단점이 있다.  
정확히는 너무 의존적이여서, 다른 인스턴스를 넣어서 테스트한다던가 할 수 없다.   

```
    // NullPointer Exception 이 뜬다.
    @Test
    void fieldInjectionTest(){
        OrderServiceImpl orderService = new OrderServiceImpl();
        orderService.createOrder(1L, "itemA", 10000);
    }
```
위 코드처럼 만약 `생성자` or `Setter`가 없다면       
테스트 코드에서는 객체를 주입해줄 방법이 없어 `NullPointerException`이 발생한다.        

이를 해결하기 위해서는 억지로라도 불필요한 `Setter`를 만들어야한다.   

```java
    @Test
    void fieldInjectionTest(){
        OrderServiceImpl orderService = new OrderServiceImpl();
        
        orderService.setMemberRepository(new MemoryMemberRepository());
        orderService.setDiscountPolicy(new FixDiscountPolicy());

        orderService.createOrder(1L, "itemA", 10000);
    }
```
물론, 스프링 테스트를 이용하여 테스트를 진행할 수 있지만     
컨테이너를 올리고 서버를 띄우는 무거운 작업을 번번히 해줘야하며       
순수 자바 코드로 이루어진 단위 테스트는 진행할 수 없다.         
            
또한 `Setter`가 생성되었기에, 불변을 보장할 수 없으며      
차라리 `Setter` 의존 관계 주입을 하는 것이 더 나을 수 있을거라 생각이든다.       
      
필드 의존 관계 주입에 대해서 말하자면, 사용하지 말자!     
애플리케이션의 실제 코드와 관계 없는 테스트 코드,      
스프링 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 특별한 용도로 사용하자      

참고로, `@Configuration`이 붙어있는 클래스는 빈을 등록하는 클래스일 것이다.   
그렇기에 `@Autowired`를 필드 의존 관계 주입으로 붙여서 사용하는 것도 나쁘지 않다.   
하지만, `@Bean` 에서 파라미터에 의존관계는 자동 주입된다는 특징이 있으니  
오히려 `@Bean` 파라미터를 이용하는 편이 낫다.  
  
## 일반 메서드 주입
일반 메서드에서도 `@Autowired`를 통해 의존 관계 주입을 받을 수 있다.   

**특징**   
* 한번에 여러 필드를 주입받을 수 있다.   
* 하지만, 일반적으로 사용하지는 않는다.  

```java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OrderServiceImpl implements OrderService {

    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }

    @Autowired
    public final void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

}
```
파라미터에 존재하는 여러 필드를 대상으로 의존받을 수 있다는 것이 장점이다.       
여기에 **만약 빈이 아닌 다른 필드가 하나라도 온다면?** 당연하게도 동작하지 않는다.        
  
# 옵션처리   
가끔은 주입할 스프링 빈이 없어도 동작을 해야하는 경우도 있을 것이다.      
그런데 `@Autowired`만 사용하면 `required` 옵션의 기본값이 true 로 되어 있어서      
자동 주입 대상이 없으면 오류를 발생시킨다.     
           
이런 자동 주입 대상을 `옵션`으로 처리하는 방법은 다음과 같다.        
* **@Autowired(required=false) :** 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안된다.      
* **org.springframework.lang.@Nullable :** 자동 주입할 대상이 없으면 `null`이 입력된다.    
* **Optional<> :** 자동 주입할 대상이 없으면 `Optional.empty`가 입력된다.    
   
**src.test.hello.core.autowired.AutowiredTest**  
```java
package hello.core.autowired;

import hello.core.member.Member;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.lang.Nullable;

import java.util.Optional;

public class AutowiredTest {

    @Test
    void AutowiredOption() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class);
    }

    static class TestBean {

        @Autowired(required = false) // 빈이 없을 경우, 해당 메서드를 호출하지 않는다. DI 안한다.
        public void setNoBean1(Member noBean1) {
            // 스프링이 관리하지 않는 빈을 파라미터로 받았다.
            System.out.println("noBean1 = " + noBean1);
        }

        @Autowired
        public void setNoBean2(@Nullable Member noBean2) { // 호출은 되지만 null
            System.out.println("noBean2 = " + noBean2);
        }

        @Autowired
        public void setNoBean2(Optional<Member> noBean3) { // Optional.empty
            System.out.println("noBean3 = " + noBean3);
        }

    }
}

```
`Member`는 스프링 빈이 아니라는 특징을 이용해서 만든 테스트케이스다.           
`setNoBean1()` 은 `@Autowired(required=false)` 이므로 호출 자체가 안된다.   
`@Autowired(required=false)`는 주입할 대상이 없으면 호출을 하지 않기 때문이다.   
   
**실행 결과**
```
noBean3 = Optional.empty
noBean2 = null
```
`@Nullable, Optional`은 스프링 전반에 걸쳐서 지원된다.      
예를 들어서 생성자 자동 주입에서 특정 필드에만 사용해도 된다.    
    
# 생성자 주입을 사용해라!    
최근, 스프링 프레임워크를 포함한 DI 프레이뭐크 대부분이 생성자 주입을 권장하고 있다.     
        
**불변**       
* 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다.   
  오히려, 애플리케이션 종료 전까지 변하면 안된다.         
* 수정자 주입을 사용하면, 메서드를 public으로 열어두고 이로인해 변경 가능성이 높아진다.   
* 생성자 주입은 객체를 생성할 때, 딱 1번만 호출되므로 이후에 호출되는 일이 없다.   
      
**누락**        
`Setter 의존 관계 주입`을 기준으로 설명을 해보려 한다.     
      
프레임워크 없이 순수한 자바 코드를 이용한다고 가정 할 때            
우선, 객체를 생성하고, `Setter`를 통해서 의존 관계를 직접 넣어주어야한다.             
그런데 만약, `Setter` 호출을 하지 않는 경우는 어떻게 될까?              
  
```java

```
```
```   
아이러니하게도 `컴파일 에러`가 발생하지 않으며 `NullPointerException`이 발생할 것이다.       
이렇듯, `Setter`는 일종의 메서드이기 때문에 호출을 누락할 수 있다는 문제점이 있다.   

**final**   
