# 빈 스코프란?      
지금까지 우리는 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어, 스프링 컨테이너가 종료될 때 까지 유지된다고 알고있다.  
**그런데 이 빈의 생명주기를 꼭 프로그램의 시작과 종료까지로 존재시켜야 할까?🤔**             
                   
기존에 우리가 알고 있는 방식은 싱글톤 스코프이다.         
싱글톤 스코프는 스프링에서 기본으로 설정되어 있는 스코프로 프로그램의 시작과 종료까지 존재한다.      
하지만, `스코프`라는 이름에서 알 수 있듯이 범위의 한 종류일 뿐이다.   
즉, 스프링에서는 싱글톤 스코프 외에 다른 스코프들도 존재한다.   
       
**스프링은 다음과 같은 다양한 스코프를 지원한다.**     
* **Singletone:** 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.      
* **prototype:** 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.     
* **request:** 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다.    
* **session:** 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.    
* **application:** 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프이다.    
    
이러한 빈 스코프는 `@Scope`라는 어노테이션을 통해 설정할 수 있으며       
빈 등록시 설정하는 것이기에 `@Bean`어노테이션과 함께 사용해야한다.          
   
**컴포넌트 스캔 등록**
```java
@Scope("prototype")
@Component
public class HelloBean {}
```
   
**수동 등록**
```java
@Scope("prototype")
@Bean
PrototypeBean HelloBean() {
    return new HelloBean();
}
```

# 프로토타입 스코프    
빈을 요청할 때마다, 매번 같은 빈과 의존 관계 주입을 맺는 싱글톤 스코프와 달리,        
프로토타입 스코프는 빈을 요청할 때마다 매번 새롭게 생성된 빈과 의존 관계 주입을 맺는다.    
           
더 상세하게 설명하자면,               
프로토타입 스코프의 빈은 **빈 생성 과정 및 사용**까지는 싱글톤 빈과 동일하기에             
**빈 생성 -> 의존 관계 주입 -> 초기화** 단계 까지는 동일하게 적용되나               
이후 부터는 스프링에서 빈을 관리하지 않는다는 전략을 가지고 있다.                
그리고 미리 생성되는 것이 아니라 빈을 요청할 때 생성한다는 특징도 가지고 있다.         
         
즉, 초기화 이후에는 스프링 컨테이너에서 빈을 관리하지 않기 때문에       
클라이언트에서 빈을 관리해야한다는 책임을 넘겨받게 된다.      
그리고 이로인해 `PreDestroy` 같은 종료 메서드가 호출되지도 않는다.           
      
**SingletonTest**   
```java
package hello.core.scope;

import org.junit.jupiter.api.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Scope;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import static org.assertj.core.api.Assertions.assertThat;

public class SingletonTest {

    @Test
    void singletonBeanFind() {
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SingletonBean.class);

        SingletonBean singletonBean1 = ac.getBean(SingletonBean.class);
        SingletonBean singletonBean2 = ac.getBean(SingletonBean.class);

        System.out.println("singletonBean1 = " + singletonBean1);
        System.out.println("singletonBean2 = " + singletonBean2);

        assertThat(singletonBean1).isSameAs(singletonBean2);

        ac.close();
    }


    @Scope(scopeName = "singleton")
    static class SingletonBean {

        @PostConstruct
        public void init() {
            System.out.println("SingletonBean.init");
        }

        @PreDestroy
        public void destroy() {
            System.out.println("SingletonBean.destroy");
        }

    }
}
```
   
**PrototypeTest**
```java
package hello.core.scope;

import org.junit.jupiter.api.Test;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Scope;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import static org.assertj.core.api.Assertions.assertThat;

public class PrototypeTest {

    @Test
    void prototypeBeanFind() {
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class);

        System.out.println("find prototypeBean1, bean is create at this request time");
        PrototypeBean prototypeBean1 = ac.getBean(PrototypeBean.class);

        System.out.println("find prototypeBean2, bean is create at this request time");
        PrototypeBean prototypeBean2 = ac.getBean(PrototypeBean.class);

        System.out.println("singletonBean1 = " + prototypeBean1);
        System.out.println("singletonBean2 = " + prototypeBean2);

        assertThat(prototypeBean1).isNotSameAs(prototypeBean2);

        ac.close();
    }


    @Scope(scopeName = "prototype")
    static class PrototypeBean {

        @PostConstruct
        public void init() {
            System.out.println("PrototypeBean.init");
        }

        @PreDestroy
        public void destroy() {
            System.out.println("PrototypeBean.destroy");
        }

    }
}
```
      
싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행 되지만,         
**프로토타입 스코프의 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행된다.**           
프로토타입 빈을 2번 조회했으므로 완전히 다른 스프링 빈이 생성되고, 초기화도 2번 실행된 것을 확인할 수 있다.    
         
싱글톤 빈은 스프링 컨테이너가 관리하기 때문에 스프링 컨테이너가 종료될 때 빈의 종료 메서드가 실행되지만,      
프로토타입 빈은 스프링 컨테이너가 생성과 의존관계 주입 그리고 초기화 까지만 관여하고, 더는 관리하지 않는다.       
따라서 프로토타입 빈은 스프링 컨테이너가 종료될 때 @PreDestory 같은 종료 메서드가 전혀 실행되지 않는다.    
         
**프로토타입 빈의 특징 정리**      
* 스프링 컨테이너에 요청할 때 마다 새로 생성된다.   
* 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.    
* 종료 메서드가 호출되지 않는다.    
* 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다.      
* 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.    

# 프로토타입과 싱글톤 빈과 함께 사용시 문제점   











