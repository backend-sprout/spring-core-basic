# 빈 생명주기 콜백 시작  
우선, `빈 생명 주기 콜백`에 대해서 간단히 말하자면      
스프링 빈이 생성되거나 소멸하기 직전에 빈 안에 있는 메서드를 호출하는 기능이다.       
   
데이터베이스 커넥션 풀이나, 네트워크 소켓처럼    
애플리케이션 **시작 시점에 필요한 연결을 미리 해두고,**   
애플리케이션 **종료시점에 연결을 모두 종료하는 작업**을 진행하려면   
**객체의 초기화와 종료 작업이 필요하다.**      
           
**우선 이렇게 하는 이유가 무엇일까?🤔**        
답은 간단하다. 속력과 안정성을 위해서 하는 것이다.        
사용자가 Request를 보낼 때마다 연결을 하고         
사용자에게 Response를 보낼 때 연결을 끊는 작업을 반복하면        
시간이 상당히 지연되고, 문제가 발생했을 때 바로 대처하기 힘들다.         
`커넥션 풀`처럼 미리 만들어 놓고 제공해준다면      
속도도 훨씬 빨라질 것이고, 문제가 발생해도 미리 대처할 수 있을 것이다.     
          
그렇기에 필요한 연결이나 객체들을 미리 만들어 놓고         
이를 안전하게 끊을 수 있는 작업을 따로 마련해두는 것이 좋다.         
        
간단하게 외부 네트워크에 미리 연결하는 객체를 하나 생성한다고 가정해보자,   
실제로 네트워크에 연결하는 것은 아니고 단순히 문자만 출력하도록 한다.         
`NetworkClinet`클래스는 애플리케이션 시작 지점에 `connect()`를 호출해서 연결을 맺어야 하고       
종료 시점에 `disConnect()`를 호출해서 연결을 끊어야 한다.          
   
**NetworkClient**    
```java
package hello.core.lifecycle;

public class NetworkClient {

    private String url;

    public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
        connect();
        call("초기화 연결 메시지");
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public void connect() {
        System.out.println("connect : " + url);
    }

    public void call(String message) {
        System.out.println("call : " + url + " message = " + message);

    }

    public void disconnect() {
        System.out.println("close" + url);
    }
}
```   
   
**BeanLifeCycleTest**
```java  
package hello.core.lifecycle;

import org.junit.jupiter.api.Test;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

public class BeanLifeCycleTest {

    @Test
    void lifeCycleTest() {
        ConfigurableApplicationContext ac = new AnnotationConfigApplicationContext(LifeCycleConfig.class);
        NetworkClient client = ac.getBean(NetworkClient.class);
        ac.close();
    }

    @Configuration
    static class LifeCycleConfig {

        @Bean
        public NetworkClient networkClient() {
            NetworkClient networkClient =  new NetworkClient();
            networkClient.setUrl("http://hello-spring.dev");
            return networkClient;
        }
    }
}

```   
```java
생성자 호출, url = null
connect : null
call : null message = 초기화 연결 메시지
```  
의존 관계를 생각했을 때, 우리는 원치 않는 값이 나오는 것을 알 수 있다.            
사실 `의존 관계 주입`은 객체를 생성할 때 호출되지 않는다.           
객체가 생성되고 난 후, 의존 관계를 주입하는 것이다.          
즉, 객체를 생성한 다음에 외부에서 수정자 주입을 통해서 `setUrl()` 이 호출되어야 `url`이 존재하게 된다
어떻게 보면 당연한 이야기이지만, `생성자와 함께 의존 관계를 주입한다!`라고 헷갈릴 수 있기에 정리한다.         
     
스프링 빈은 간단하게 다음과 같은 라이프 사이클을 가진다.         
**객체 생성** -> **의존 관계 주입**        
    
스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.        
따라서 초기화 작업은 의존관계 주입이 모두 완료가 되고 난 다음에 호출해야 한다.      
**그런데 개발자가 의존 관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까? 🤔**     
         
스프링은 **의존 관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다.**        
또한, 스프링은 스프링 컨테이너가 종료되기 직전 소멸 콜백을 준다.        
따라서 안전하게 종료 작업을 진행할 수 있다.       
     
**스프링 빈의 이벤트 라이프사이클**        
1. 스프링 컨테이너 생성      
2. 스프링 빈 생성       
3. 의존관계 주입      
4. 초기화 콜백          
5. 사용      
6. 소멸 전 콜백     
7. 스프링 종료      
           
조금 헷갈릴 부분이 있어서 조금 조정하자면,           
객체 생성 단계에서 `1~4`단계를 모두 거치기에, 객체가 생성되었다면 4단계까지 완료된 것이다.         
   
* **초기화 콜백 :** 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출    
* **소멸전 콜백 :** 빈이 소멸되기 직전에 호출     
     
스프링은 다양한 방식으로 생명주기 콜백을 지원한다.     
      
**참고: 객체의 생성과 초기화를 분리하자.**     
* 생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다.        
  반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는등 무거운 동작을 수행한다.          
* 따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는     
  객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다.       
  물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 처리하는게 더 나을 수 있다.   
  
**참고: 싱글톤 빈들은 스프링 컨테이너가 종료될 때 싱글톤 빈들도 함께 종료되기 때문에 스프링 컨테이너가 종료되기 직전에 소멸전 콜백이 일어난다.**      
* 뒤에서 설명하겠지만 싱글톤 처럼 컨테이너의 시작과 종료까지 생존하는 빈도 있지만,    
  생명주기가 짧은 빈들도 있는데 이 빈들은 컨테이너와 무관하게 해당 빈이 종료되기 직전에 소멸전 콜백이 일어난다.   
  자세한 내용은 스코프에서 알아보겠다.

 
  





   


  
