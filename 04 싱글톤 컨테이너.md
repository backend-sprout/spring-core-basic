# 웹 애플리케이션과 싱글톤   
스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생되었다.      
그렇기에 대부분의 스프링 애플리케이션은 웹 애플리케이션으로 구성되어 있다.    
물론, 웹이 아닌 애플리케이션 개발도 얼마든지 개발할 수도 있다.      
        
웹 애플리케이션의 동작 과정에서      
여러 사람이 접근해서 동시에 여러 `request`를 보내면 어떤 방식으로 동작을 할까?      
물론, 이전에 우리가 배웠듯이 `DI 컨테이너`에 등록된 빈을 가지고 요청을 처리할 것이다.      
그런데 **여러 사람이 동시에 여러 `request`를 보낸다는거니까 객체도 그만큼 많이 생성되어야 하나?🤔**     
그렇다면 **1000명, 10000명, 1억명이 들어온다면 그만큼 객체를 생성해야하나?** 라는 의심이 들 수 있다.    
                
우선, 결론부터 말하면 스프링은 기본적으로 `싱글톤`으로 빈을 관리한다.             
그리고 `WAS`의 쓰레드풀에 존재하는 여러 쓰레드를 통해 `빈 인스턴스에 접근`을 하는 것이다.   
(물론, 이 과정에서 `thread-safe`한 빈을 등록하는 것이 좋을 것이다.)        
      
이를 확인하기 위해서 간단한 예제를 만들어 보려고 한다.  
우선은, AppConfig에서 바로 객체를 받아서 사용하는 방식  
즉, 싱글톤이 적용되지 않은 코드를 작성해보겠다.   

```java
package hello.core.singleton;

import hello.core.AppConfig;
import hello.core.member.MemberService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class SingletonTest {

    @DisplayName("스프링 없는 순수 DI 컨테이너")
    @Test
    void pureContainer() {
        AppConfig appConfig = new AppConfig();
        // 1. 조회 -> 호출할 때마다 객체 생성하는지 조회
        MemberService memberService = appConfig.memberService();

        // 2. 조회 -> 호출할 때마다 객체 생성하는지 조회
        MemberService memberService2 = appConfig.memberService();

        // 참조값이 다른지 확인
        assertThat(memberService).isNotSameAs(memberService2);
    }


}
```
순수한 `DI 컨테이너`인 `AppConfig`는 요청을 할 때 마다 객체를 새로 생성한다.      
만약, 고객 트래픽이 초당 100이 나오면 초당 100개의 객체가 생성되고 소멸된다!        
즉, 메모리 낭비가 심하다.           
해결방안은 해당 객체가 딱 1개만 생성되고, 공유하는 싱글톤 패턴으로 설계하면 된다.              
  
# 싱글톤 패턴   
싱글톤 패턴이란, **인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.**     
주로, `private` 생성자를 사용해서 외부에서 임의로 **new 키워드를 사용하지 못하도록 막아야 한다**     
싱글톤 패턴에 대해서 [필자가 정리한 내용]()이 있으니 여길 참고하는 걸 적극 추천한다.     
  
```java
public final class SingletonService {

    private static final SingletonService instance = new SingletonService();

    private SingletonService() {}

    public static final SingletonService getInstance() {
        return instance;
    }

    public void logic() {
        System.out.println("싱글톤 객체 로직 호출");
    }
}
```
`private`으로 `new` 키워드를 막아두었다.   
호출할 때 마다 같은 객체 인스턴스를 반환하는 것을 확인할 수 있다.     
  
1. `static` 영역에 객체 `instance`를 미리 하나 생성해서 올려둔다.        
2. 이 객체 인스턴스가 필요하면 오직 `getInstance() 메서드`를 통해서만 조회할 수 있다.   
  이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.      
3. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 `private`으로 막아서        
혹시라도 외부에서 `new` 키워드로 객체 인스턴스가 생성되는 것을 막는다.        

```java
  
package hello.core.singleton;

import hello.core.AppConfig;
import hello.core.member.MemberService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class SingletonTest {

    @DisplayName("스프링 없는 순수 DI 컨테이너")
    @Test
    void pureContainer() {
        AppConfig appConfig = new AppConfig();
        // 1. 조회 -> 호출할 때마다 객체 생성하는지 조회
        MemberService memberService1 = appConfig.memberService();

        // 2. 조회 -> 호출할 때마다 객체 생성하는지 조회
        MemberService memberService2 = appConfig.memberService();

        // 참조값이 다른지 확인
        assertThat(memberService1).isNotSameAs(memberService2);
    }

    @DisplayName("싱글톤 패턴을 적용한 사례")
    @Test
    void singletonServiceTest() {
        SingletonService singletonService1 = SingletonService.getInstance();
        SingletonService singletonService2 = SingletonService.getInstance();

        System.out.println("singletonService1 = " + singletonService1);
        System.out.println("singletonService2 = " + singletonService2);

        assertThat(singletonService1).isSameAs(singletonService2);

        singletonService1.logic();
    }

}
```
싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라,      
이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.       
하지만 싱글톤 패턴은 다음과 같은 수 많은 문제점들을 가지고 있다.    

**싱글톤 패턴 문제점**
* 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
* 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.
* 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
* 테스트하기 어렵다.
* 내부 속성을 변경하거나 초기화 하기 어렵다.
* private 생성자로 자식 클래스를 만들기 어렵다.
* 결론적으로 유연성이 떨어진다.
* 안티패턴으로 불리기도 한다.

